---
title-block-banner: true
title: "Analysis of PDGFR-Î² mRNA (FISH) in the injured brain following cerebral ischemia"
subtitle: "Data analysis notebook"
date: today
date-format: full
author: 
  - name: "Daniel Manrique-Castano"
    orcid: 0000-0002-1912-1764
    degrees:
      - PhD
    affiliation: 
      - name: Univerisity Laval 
        department: Psychiatry and Neuroscience
        group: Laboratory of neurovascular interactions 
note: "GitHub: https://daniel-manrique.github.io/"
keywords: 
  - PDGFR-Î²
  - Flourescence in situ hybridization (FISH)
  - Brain injury
  - Bayesian modeling 
   
license: "CC BY"

format:
   pdf: 
    toc: true
    number-sections: true
    colorlinks: true
   html:
    code-fold: true
    embed-resources: true
    toc: true
    toc-depth: 2
    toc-location: left
    number-sections: true
    theme: spacelab

knitr:
  opts_chunk: 
    warning: false
    message: false
    
csl: science.csl
bibliography: references.bib
---

# Preview

This notebook reports the analysis of PDGFR-Î² expression (by FISH) in the injured brain following cerebral ischemia. Previous results using PDGFR-Î²(Td-tomato from transgenic animals) suggest that KLF4 depletion reduces PDGFR-Î² expression. To confirm those results we evaluated PDGFR-Î² at mRNA levels. 

**Parent dataset:** PDGFR-Î²(FISH) stained ischemic hemispheres imaged at 10x (with stitching). We took regions of interest (ROIs) from three different areas in the injure cortex/striatum to quantify PDGFR-Î² expression. Samples are grouped at 0 (Sham), and 14 days post-ischemia (DPI). The raw images and pre-processing scripts (if applicable) are available at the Zenodo repository (10.5281/zenodo.10553084) under the name `Widefield_10x_ROIs_KO_Fish_Pdgfrb.zip`.

**Working dataset**: The `Data_Raw/Widefield_10x_ROIs_KO_Fish_Pdgfrb/Widefield_10x_ROIs_KO_Fish_Pdgfrb_Pdgfrb_Objects.csv dataframes containing the raw output from CellProfiller [@stirling2021]. The CellProfiler pipeline is available at https://osf.io/yndua.

We perform scientific inference based on the number of cells, intensity and area. We also perform PPA and TDA to evaluate topological features of cells.

# Install and load required packages

Install and load all required packages. Please uncomment (delete #) the line code if installation is required. Load the installed libraries each time you start a new R session.

```{r}
#| label: Install_Packages
#| include: true
#| warning: false
#| message: false

#install.packages("devtools")
#library(devtools)

#install.packages(c("bayesplot", "bayestestR", "brms","dplyr", "easystats", "ggplot","gtsummary", "modelbased", "modelr", "modelsummary", "patchwork", "poorman","plyr", "reshape2", "spatstat", "scales", "tidybayes", "tidyverse", "viridis"))


library(bayesplot)
library(bayestestR)
library(brms)
library(dplyr)
library(easystats)
library(emmeans)
library(ggplot2)
library(gtsummary)
library(modelbased)
library(modelr)
library(modelsummary)
library(patchwork)
library(poorman)
library(plyr)
library(reshape2)
library(spatstat)
library(scales)
library(tidybayes)
library(tidyverse)
library(viridis)
```
# Visual themes

We create a visual theme to use in our plots (ggplots).

```{r}
#| label: Plot_Theme
#| include: true
#| warning: false
#| message: false
  
Plot_theme <- theme_classic() +
  theme(
      plot.title = element_text(size=18, hjust = 0.5, face="bold"),
      plot.subtitle = element_text(size = 10, color = "black"),
      plot.caption = element_text(size = 12, color = "black"),
      axis.line = element_line(colour = "black", size = 1.5, linetype = "solid"),
      axis.ticks.length=unit(7,"pt"),
     
      axis.title.x = element_text(colour = "black", size = 16),
      axis.text.x = element_text(colour = "black", size = 16, angle = 0, hjust = 0.5),
      axis.ticks.x = element_line(colour = "black", size = 1),
      
      axis.title.y = element_text(colour = "black", size = 16),
      axis.text.y = element_text(colour = "black", size = 16),
      axis.ticks.y = element_line(colour = "black", size = 1),
      
      legend.position="right",
      legend.direction="vertical",
      legend.title = element_text(colour="black", face="bold", size=12),
      legend.text = element_text(colour="black", size=10),
      
      plot.margin = margin(t = 10,  # Top margin
                             r = 2,  # Right margin
                             b = 10,  # Bottom margin
                             l = 10) # Left margin
      ) 
```

# Analysis of the number of PDGFR-Î² cells

## Load and handle the datasets

We load the `Data_Raw/Widefield_10x_ROIs_KO_Fish_Pdgfrb/Widefield_10x_ROIs_KO_Fish_Pdgfrb_Image.csv` datasets containing raw cell counts from cellProfiler.

```{r}
#| label: tbl-Pdgfrb_Counts_Table
#| include: true
#| warning: false
#| message: false
#| tbl-cap: "Data set"

# We load the dataset in case is not present in the R environment
Pdgfrb_df <- read.csv(file = "Data_Raw/Widefield_10x_ROIs_KO_Fish_Pdgfrb/Widefield_10x_ROIs_KO_Fish_Pdgfrb_Image.csv", header = TRUE)

gt::gt(Pdgfrb_Counts[1:10,])
```

We are interested in the `FileName_Pdgfrb_Raw`column containing the identification data for the images and the `Count_Pdgfrb_Objects` indicating the number of PDGFR-Î²+ cells. Next, we subset the data frame to select the columns of interest and give them meaningful names.

```{r}
#| label: Pdgfrb_Counts_Handle
#| include: true
#| warning: false
#| message: false
#| tbl-cap: "Data set"

## We subset the relevant columns (cell number)
Pdgfrb_Counts <- subset(Pdgfrb_df, select = c("FileName_Pdgfrb_Raw", "Count_Pdgfrb_Objects"))

## And extract metadata from the image name
Pdgfrb_Counts  <- cbind(Pdgfrb_Counts, do.call(rbind , strsplit(Pdgfrb_Counts$FileName_Pdgfrb_Raw, "[_\\.]"))[,1:4])

Pdgfrb_Counts <- subset(Pdgfrb_Counts, select = -c(FileName_Pdgfrb_Raw))

## We Rename the relevant columns 
colnames(Pdgfrb_Counts) <- c("Counts", "MouseID", "DPI", "Genotype", "Section")

## We set the factors
Pdgfrb_Counts$DPI <- factor(Pdgfrb_Counts$DPI, levels = c("0D", "14D"))
Pdgfrb_Counts$Genotype <- factor(Pdgfrb_Counts$Genotype, levels = c("WT", "KO"))
Pdgfrb_Counts$Section <- factor(Pdgfrb_Counts$Section, levels = c("S1", "S2", "S3"))

write.csv(Pdgfrb_Counts, "Data_Processed/Widefield_10x_ROIs_KO_Fish_Pdgfrb/Widefield_10x_ROIs_KO_Fish_Pdgfrb_Counts.csv", row.names = FALSE)

```

With the data handled, we perform exploratory data visualization.

## Exploratory data visualization

We plot the data to see its distribution and have a first hint for modeling strategies.

```{r}
#| label: fig-Pdgfb_Counts_Expl
#| include: true
#| warning: false
#| message: false
#| results: false
#| fig-cap: Exploratory data visualization for the number of PDGFR-Î²+ cells
#| fig-width: 9
#| fig-height: 4

set.seed(8807)

# Boxplot
##################

Pdgfrb_Counts_box <- 
  ggplot(
    data  = Pdgfrb_Counts, 
    aes(x = DPI, 
        y = Counts,
        color = Genotype)
    ) +
  geom_boxplot() +

scale_y_continuous(name = "Number of PDGFR-Î²+ cells") +
scale_x_discrete(
  name   ="Days post-ischemia (DPI) ",
  breaks = c("0D", "14D")
  ) +
Plot_theme

#Plot the result
Pdgfrb_Counts_box
```

@fig-Pdgfb_Counts_Expl shows that cerebral ischemia comprises an increase in the number of PDGFR-Î² cells. The plots at 14D show a tiny difference between the means of the two genotypes.

## Statistical modeling for the number of PDGFR-Î²+ cells

Given that we took three different photos per animal, we'll fit a multilevel model to capture the both the population-level effects of Genotype and the group variability due to individual differences among the mice. We fit the following model:

 - **Pdgfrb_Counts_Mdl1:** Considers `Genotype` as a predictor and `MouseID` as random effects. The model takes the following notation:
 
 $$
 Counts_i = \beta_0 + \beta_1 \times Genotype_i + u_{MouseID[i]} + \epsilon_i
 $$
Where $Î²0$ is the intercept, $ð›½1$, represents the effect of Genotype on Counts. $ð‘¢MouseID$ is the group-level effect associated with the $ð‘–$i-th mouse, and $ðœ–$ denotes the residual error terms.
 .
By including (1 | MouseID), we accounts for the fact that observations from the same mouse are likely to be more similar to each other than to observations from different mice

### Fit the models

We employ `brms` to fit the model.

```{r}
#| label: Pdgfrb_Counts_Fit1
#| include: true
#| warning: false
#| message: false
#| results: false
#| cache: true

Pdgfrb_Counts_14D <- Pdgfrb_Counts[Pdgfrb_Counts$DPI == "14D",]

# Model 1: Genotype as a linear predictor
###########################################
Pdgfrb_Counts_Mdl1 <- bf(Counts ~ Genotype + (1 | MouseID))

get_prior(Pdgfrb_Counts_Mdl1, Pdgfrb_Counts_14D , family = negbinomial())

# Fit model 1
Pdgfrb_Counts_Fit1 <- 
  brm(
    family  = negbinomial(),
    data    = Pdgfrb_Counts_14D,
    formula = Pdgfrb_Counts_Mdl1,
    chains  = 4,
    cores   = 4,
    warmup  = 2500, 
    iter    = 5000, 
    seed    = 8807,
    control = list(adapt_delta = 0.99, max_treedepth = 15),
    file    = "Models/Widefield_10x_ROIs_KO_Fish_Pdgfrb/Widefield_10x_ROIs_KO_Fish_Pdgfrb_Counts_Fit1.rds",
    file_refit = "never")
```

### Model diagnostics

To evaluate sample predictions, we perform the model diagnostics using the `pp_check` (posterior predictive checks) function from `brms`. In the graph, ð˜º shows the data and y\~ the simulated data.

```{r}
#| label: fig-Pdgfrb_Counts_Diagnostics
#| include: true
#| warning: false
#| message: false
#| results: false
#| fig-cap: Model diagnostics for the number of PDGFR-Î²+ cells
#| fig-height: 4
#| fig-width: 5

set.seed(8807)

Pdgfrb_Counts_Fit1_pp <- 
  brms::pp_check(Pdgfrb_Counts_Fit1, 
                 ndraws = 100) +
  labs(title = "Posterior predictive checks",
  subtitle = "Formula: Counts ~ Genotype + (1 | MouseID)") +
  Plot_theme  
  
Pdgfrb_Counts_Fit1_pp
```

We see that our model captures the trend of the observations.

## Model results

### Visualizaing the posterior

After validating the model, we plot the full posterior distributions for the population and group (Mouse) level effects.:

```{r}
#| label: fig-Pdgfrb_Counts_Posterior
#| include: true
#| warning: false
#| message: false
#| results: false
#| fig-cap: Posterior distribution for the number of of PDGFR-Î²+ cells
#| fig-width: 10
#| fig-height: 4

# For population-Level effects:

set.seed(8807)

Pdgfrb_Count_Draws <- Pdgfrb_Counts_14D %>%
  group_by(Genotype, MouseID) %>% 
  add_predicted_draws(Pdgfrb_Counts_Fit1, re_formula = NA) 

# Plotting
Pdgfrb_Count_fig <- ggplot(Pdgfrb_Count_Draws, aes(x = Genotype, y = .prediction)) +
  stat_halfeye() + # Visualize the posterior predictive distribution
  geom_jitter(data = Pdgfrb_Counts_14D, aes(x = Genotype, y = Counts),
              width = 0.15, alpha = 0.6, size = 2) + # Actual measurements
  labs(x = "Genotype") + 
  scale_y_continuous(name = "Number of PDGFR-Î²+ cells",
                     limits = c(0, 400),
                      breaks = seq(0, 400, 100) ) +
  Plot_theme +
  coord_flip()

ggsave(
  plot     = Pdgfrb_Count_fig, 
  filename = "Plots/Widefield_10x_ROIs_KO_Fish_Pdgfrb/Widefield_10x_ROIs_KO_Fish_Pdgfrb_Counts.png", 
  width    = 9, 
  height   = 9, 
  units    = "cm")

# For Group-Level effects

# Extracting group-level effects
posterior_samples <- Pdgfrb_Counts_Fit1 %>% 
  spread_draws(r_MouseID[MouseID,])  # Extract random effects for AnimalID

# Plotting the group-level effects
Pdgfrb_Counts_group <- ggplot(posterior_samples, 
                              aes(x = reorder(MouseID,r_MouseID), 
                                  y = r_MouseID)) +
  stat_halfeye(fill = "lightgray", color = "black") +
  labs(title = "Mouse-Level effects",
       x = "MouseID",
       y = "Deviation from mean") +
  coord_flip()+
    geom_hline(yintercept=0, size=1, linetype=2)+
  Plot_theme

ggsave(
  plot     = Pdgfrb_Counts_group, 
  filename = "Plots/Widefield_10x_ROIs_KO_Fish_Pdgfrb/Widefield_10x_ROIs_KO_Fish_Pdgfrb_Group.png", 
  width    = 9, 
  height   = 12, 
  units    = "cm")


Pdgfrb_Count_fig + Pdgfrb_Counts_group

```

@fig-Pdgfrb_Counts_Posterior shows the full posterior distribution for population and group (MouseID) level effects. We see that WT and KO mice does not differ meaningfully in the number of PDGFR-B cells. 


### Posterior summary

Next, we plot the posterior summary using the `describe_posterior` function from `bayestestR` package [@bayestestR; @makowski2019].

```{r}
#| label: Klf4_Int_DescribePosterior
#| include: true
#| warning: false
#| message: false
#| results: false
#| cache: true

describe_posterior(
  Pdgfrb_Counts_Fit1,
  effects = "all",
  test = c("p_direction", "rope"),
  component = "all",
  centrality = "median")

modelsummary(Pdgfrb_Counts_Fit1, 
             shape = term ~ model + statistic,
             centrali2ty = "mean", 
             title = "Nuber of PDGFR-B cells in defined ROIs of the ipsilateral hemisphere",
             statistic = "conf.int",
             gof_omit = 'ELPD|ELDP s.e|LOOIC|LOOIC s.e|WAIC|RMSE',
             output = "Tables/html/Widefield_10x_ROIs_KO_Fish_Pdgfrb_Counts_Fit1_Table.html",
             )

Pdgfrb_Counts_Fit1_Table <- modelsummary(Pdgfrb_Counts_Fit1, 
             shape = term ~ model + statistic,
             centrality = "mean", 
             statistic = "conf.int",
             gof_omit = 'ELPD|ELDP s.e|LOOIC|LOOIC s.e|WAIC|RMSE',
             output = "gt")
gt::gtsave (Pdgfrb_Counts_Fit1_Table, filename = "Tables/tex/Widefield_10x_ROIs_KO_Fish_Pdgfrb_Counts_Fit1_Table.tex")


# Extract the tidy data frame from the brms model object
tidy_model <- tidy(Pdgfrb_Counts_Fit1)

# Create the flextable object
ft <- flextable(tidy_model)

# Customize the flextable (optional)
ft <- theme_vanilla(ft)
ft <- autofit(ft)

# Display the flextable
ft

```
The table displays the regression coefficients o the log scale.


# Analysis of PDGFR-B area and intensity

## Dataset handling

We handle the `Klf4_Data` to add scaled coordinates

```{r}
#| label: Klf4_Int_Scale
#| include: true
#| warning: false
#| message: false
#| results: false
#| cache: true

Klf4_Data <- read.csv("Data_Processed/Widefield_10x_Ipsilateral_Klf4/Widefield_10x_Ipsilateral_Klf4_Klf4Inten.csv", header = TRUE)

## We set the factors
Klf4_Data$DPI <- factor(Klf4_Data$DPI, levels = c("0D", "3D", "7D", "14D", "30D"))

Klf4_Data <- Klf4_Data %>%
  group_by(MouseID) %>%
  mutate(Scaled_CenterX = (CenterX - min(CenterX)) / (max(CenterX) - min(CenterX)),
         Scaled_CenterY = (CenterY - min(CenterY)) / (max(CenterY) - min(CenterY))) %>%
  ungroup()

Klf4_Data$MouseID <- factor(Klf4_Data$MouseID)
```

## Exploratory data visualization

Next, we visualize the raw data to guide the statistical modeling. We plot the response variable as a density and a scatter plot (per DPI). In the scatter plot, we fit lines for a lineal (black), 2-degree (red), and 3-degree (green) polynomial models.

```{r}
#| label: fig-Klf4_CellInt_Expl
#| include: true
#| warning: false
#| message: false
#| results: false
#| fig-cap: Exploratory data visualization for Klf4 intensity
#| fig-width: 9
#| fig-height: 4

set.seed(8807)

# Density plot
################

Klf4_Int_Dens <- 
  ggplot(
    data  = Klf4_Data, 
    aes(x = Intensity)
    ) +
  geom_density(size = 1.5) +
  geom_rug(size = 1) +
  scale_x_continuous(name ="KLF4 (Intensity)") +
  scale_y_continuous(name = "Density") +
  Plot_theme


# Box plot
##################

Klf4_Int_Box <- 
  ggplot(
    data  = Klf4_Data, 
    aes(x = DPI, 
        y = Intensity)
    ) +
  geom_boxplot()+

Plot_theme

#Plot the result
Klf4_Int_Dens |  Klf4_Int_Box 
```

@fig-Klf4_CellInt_Expl shows a range of \~ 0 - 10 in the KFL4 intensity. Without accounting for days-post ischemia (DPI), the response variable exhibits a single concentrated peak. On the other hand, the scatter shows that there are no substantial differences between the fitted lines. We speculate that the median (per object) intensity of KLF4 does not vary meaningfully by DPI.

## Statistical modeling for Klf4 expression

We use the `brms` package [@brms; @burkner2018] to run Bayesian modeling. We employ weakly informative priors in all the cases to optimize the Markov chain Monte Carlo (MCMC) and the exploration of the parameter space. Given the exploratory data visualization, we fit a linear model to explore the variability of KLF4 by DPI. We build a multilevel model to take into consideration the clustering of cells per animal:

-   **Klf4_Int_Mdl1:** This model employs a `hurdle_lognormal()` distribution to handle data with zeros while also capturing the continuous nature of the observations. This distribution is a two-part model having a binary Component predicting the probability of observing a zero versus a positive outcome; and a continuous Component for observations predicted to be positive:

$$
\begin{aligned}
\text{logit}(p_i) &= \beta_{\text{DPI}} \times \text{DPI}_i \\
\log(Y_i) &\sim N(\mu_i, \sigma^2), \quad Y_i > 0 \\
\mu_i &= \gamma_{\text{DPI}} \times \text{DPI}_i + b_{\text{MouseID}[i]} \\
b_{\text{MouseID}[i]} &\sim N(0, \tau^2)
\end{aligned}
$$
Where, $p_i$ is the probability of observing zero intensity for mouse $i$. $\beta_{\text{DPI}}$ is the coefficient for DPI affecting the log-odds of observing a zero outcome. $Y_i$ is the intensity for mouse
$i$ when it is positive.$\mu_i$ is the expected log-intensity for a positive outcome, influenced by DPI and the random effect of the mouse.$b_{\text{MouseID}[i]}$ is the random intercept for each mouse, modeled as a normal distribution with mean zero and variance $\tau^2$.

This model uses the default flat prior from `brms`:

$$
\begin{align}
\beta_{1} \sim Normal(0, 1), \sigma > 0\\
sd \sim Student-t(3, 0, 1) \\
\sigma \sim Student-t(3, 0, 1), \sigma > 0 \\
\end{align}
$$


-   **Klf4_Int_Mdl2:** This model uses a `hurdle_lognormal()` distribution implicating that the effect of DPI may vary depending the X location. The model takes the following formulation: 

$$
\text{For Zero vs. Positive Outcomes:} \\
\text{logit}(p_i) = \alpha_{\text{DPI}} \times \text{DPI}_i + \alpha_{\text{Location}} \times \text{Location}_i + \alpha_{\text{Interaction}} \times \text{DPI}_i \times \text{Location}_i \\
\text{For Positive Outcomes:} \\
\log(Y_i) \sim N(\mu_i, \sigma^2), \quad Y_i > 0 \\
\mu_i = \beta_{\text{DPI}} \times \text{DPI}_i + \beta_{\text{Location}} \times \text{Location}_i + \beta_{\text{Interaction}} \times \text{DPI}_i \times \text{Location}_i + b_{\text{MouseID}[i]} \\
b_{\text{MouseID}[i]} \sim N(0, \tau^2)
$$
This model use the same priors as model 1.

### Fit the models for Klf4 intensity

First, we subsample the data to make model feasible.

```{r}
#| label: Klf4_CellInt_Subsample
#| include: true
#| warning: false
#| message: false
#| results: false
#| cache: true

Klf4_Data <- Klf4_Data %>%
  mutate(MouseID = as.character(MouseID))

# Subsampling 10% of the cases for each MouseID
Klf4_Subsample <- Klf4_Data %>%
  group_by(MouseID) %>%
  sample_frac(0.1) %>%
  ungroup()  # Ungrouping to remove the grouping structure
```

Next, we fit the models using `brms`:

```{r}
#| label: Klf4_CellInt_Model
#| include: true
#| warning: false
#| message: false
#| results: false
#| cache: true

# Model 1

Klf4_CellInt_Mdl1 <- bf(Intensity ~ 0 + DPI + (1 | MouseID))

get_prior(Klf4_CellInt_Mdl1, Klf4_Subsample, family = hurdle_lognormal())

Klf4_CellInt_Prior1 <- 
  c(prior(normal(0,1), class = b, lb = 0),
    prior(student_t(3, 0, 1), class = sd, lb= 0),
    prior(student_t(3, 0, 1), class = sigma, lb=0))

# Fit model 1
Klf4_CellInt_Fit1 <- 
  brm(
    family  = hurdle_lognormal(),
    data    = Klf4_Subsample,
    formula = Klf4_CellInt_Mdl1,
    prior   = Klf4_CellInt_Prior1,
    chains  = 4,
    cores   = 4,
    warmup  = 2500, 
    iter    = 5000, 
    seed    = 8807,
    control = list(adapt_delta = 0.99, max_treedepth = 15),
    file    = "Models/Widefield_10x_Ipsilateral_Klf4_Exp/Widefield_10x_Ipsilateral_Klf4_CellInt_Fit1.rds",
    file_refit = "never")

                     
#Klf4_CellInt_Fit1 <- 
#  add_criterion(Klf4_CellInt_Fit1, c("loo", "waic", "bayes_R2"))


# Model 2

Klf4_CellInt_Mdl2 <- bf(Intensity ~ 0 + DPI * Scaled_CenterX + (1 | MouseID))

get_prior(Klf4_CellInt_Mdl2, Klf4_Subsample, family = lognormal())

# Fit model 1
Klf4_CellInt_Fit2 <- 
  brm(
    family = hurdle_lognormal(),
    data    = Klf4_Subsample,
    formula = Klf4_CellInt_Mdl2,
    prior   = Klf4_CellInt_Prior1,
    chains  = 4,
    cores   = 4,
    warmup  = 2500, 
    iter    = 5000, 
    seed    = 8807,
    control = list(adapt_delta = 0.99, max_treedepth = 15),
    file    = "Models/Widefield_10x_Ipsilateral_Klf4_Exp/Widefield_10x_Ipsilateral_Klf4_CellInt_Fit2.rds",
    file_refit = "never")

#Klf4_CellInt_Fit2 <- 
#  add_criterion(Klf4_CellInt_Fit2, c("loo", "waic", "bayes_R2"))
```
## Model diagnostics

We perform model diagnostics:

```{r}
#| label: fig-Klf4_CellInt_Diagnostics
#| include: true
#| warning: false
#| message: false
#| results: false
#| fig-cap: Model diagnostics for KLF4 expression in individual cells
#| fig-height: 5
#| fig-width: 10

set.seed(8807)

Klf4_CellInt_Fit1_pp <- 
  brms::pp_check(Klf4_CellInt_Fit1, 
                 ndraws = 100) +
  labs(title = "Posterior predictive checks",
  subtitle = "Formula: Intensity ~ 0 + DPI + (1 | MouseID)") +
  scale_x_continuous(limits=c(0, 0.05)) +
  Plot_theme  

Klf4_CellInt_Fit2_pp <- 
  brms::pp_check(Klf4_CellInt_Fit2, 
                 ndraws = 100) +
  labs(title = "Posterior predictive checks",
  subtitle = "Intensity ~ 0 + DPI * Scaled_CenterX + (1 | MouseID)") +
  scale_x_continuous(limits=c(0, 0.05)) +
  Plot_theme  
  
Klf4_CellInt_Fit1_pp | Klf4_CellInt_Fit2_pp
```

We see that the model predictions fit well with the observations in both cases.

## Model results

After validating the model, we plot the full posterior distributions:

### Visualizing the results

```{r}
#| label: fig-Klf4_CellInt_Posterior
#| include: true
#| warning: false
#| message: false
#| results: false
#| fig-cap: Posterior distribution for Klf4 expression
#| fig-width: 5
#| fig-height: 4

set.seed(8807)

Klf4_CellInt_DPI <- 
  conditional_effects(Klf4_CellInt_Fit1)

Klf4_CellInt_DPI <- plot(Klf4_CellInt_DPI, 
       plot = FALSE)[[1]]

Klf4_CellInt_fig <- Klf4_CellInt_DPI + 
  scale_y_continuous(name = expression ("KLF4 intensity (cells)"),
                     limits = c(0.005, 0.015)) +
  scale_x_discrete(name="DPI") +
  
  Plot_theme 

  ggsave(
  plot     = Klf4_CellInt_fig, 
  filename = "Plots/Widefield_10x_Ipsilateral_Klf4_Exp/Widefield_10x_Ipsilateral_Klf4_CellIntensity.png",   width    = 12, 
  height   = 9, 
  units    = "cm")

Klf4_CellInt_fig 
```

@fig-Klf4_CellInt_Posterior shows 95% intervals for the posterior distribution of KLF4 expression by cell. We can observe an increase from the second week post ischemia.

Now, we calculate the relevant contrast using the `emmeans` package [@emmeans].

```{r}
#| label: Klf4_CellInt_Contrast
#| include: true
#| warning: false
#| message: false
#| results: false

# We generate a data frame with the contrast
Klf4_CellInt_Contrast <- Klf4_CellInt_Fit1%>%
emmeans(~ DPI, var = "Intensity", epred = TRUE) %>%
contrast(method = "revpairwise") %>%
gather_emmeans_draws() %>% sample_n(100)

# Subset relevant data fo the contrast graph
Klf4_CellInt_Contrast_Sub <- Klf4_CellInt_Contrast[
  (Klf4_CellInt_Contrast$contrast=="3D - 0D"|
   Klf4_CellInt_Contrast$contrast=="7D - 3D"|
   Klf4_CellInt_Contrast$contrast=="14D - 7D"|
   Klf4_CellInt_Contrast$contrast=="30D - 14D"|
  Klf4_CellInt_Contrast$contrast=="30D - 0D"),]

Klf4_CellInt_Contrast_Sub$contrast <- 
  factor(Klf4_CellInt_Contrast_Sub$contrast, 
         levels = c("3D - 0D", "7D - 3D", "14D - 7D", "30D - 14D", "30D - 0D")) 
```

Next, we generate the graph:

```{r}
#| label: Klf4_CellInt_ContrastGraph
#| include: true
#| warning: false
#| message: false
#| results: false
#| fig-cap: Contrast by DPI for KLF4 spatial intensity
#| fig-width: 5
#| fig-height: 4

Klf4_CellInt_Contrast_Fig <- 
  Klf4_CellInt_Contrast_Sub %>%
  ggplot(
    aes(x    = .value, 
        y    = contrast
        #fill = after_stat(abs(x) < 800)
        )) +
  
  stat_slab() +
  
  #geom_vline(xintercept = c(-0.54, 0.54), linetype = "dashed") +
  
  stat_pointinterval(
    point_interval = mode_hdi, 
    position = position_dodge(width = .95, preserve = "single")) +
  
    #scale_fill_manual(
    #name="ROPE", 
    #values = c("gray80", "skyblue"),
    #labels = c("False", "True")) +
  
  scale_y_discrete(
    name= "",
    labels = c("3D - 0D", "7D - 3D", "14D - 7D", "30D - 14D", "30D - 0D")) +
  
  scale_x_continuous(
   name = "KLF4 cell intensity (contrast)",
   limits=c(-0.005, 0.006), 
   breaks=seq(-0.005, 0.005, 0.003)) +
  Plot_theme +
  
  theme (legend.position = c(0.8, 0.8))

ggsave(
  plot     = Klf4_CellInt_Contrast_Fig , 
  filename = "Plots/Widefield_10x_Ipsilateral_Klf4_Exp/Widefield_10x_Ipsi_Klf4_CellInt_Contrast_Fig.png", 
  width    = 12, 
  height   = 9, 
  units    = "cm")

Klf4_CellInt_Contrast_Fig

```

### Posterior summary

Next, we plot the posterior summary using the `describe_posterior` function from `bayestestR` package [@bayestestR; @makowski2019].

```{r}
#| label: Klf4_CellInt_Fit1_DescribePosterior
#| include: true
#| warning: false
#| message: false
#| results: false
#| cache: true

describe_posterior(
  Klf4_CellInt_Fit1,
  effects = "all",
  test = c("p_direction", "rope"),
  component = "all",
  centrality = "median")
```
The table displays the regression coefficients without a baseline (intercept value).It also shows he coefficients for individual animals included as group-level effects.





## Generate and handle point patterns

We use functions from the `spatstat` package [@baddeley2005] to create point patterns based on the coordinates of individual cells. The point patterns are then stored in a hyperframe and can be loaded into R as an R object.

```{r}
#| label: tbl-Klf4_PointPatterns
#| include: true
#| warning: false
#| message: false
#| tbl-cap: "Data set"

# Initialize the hyperframe as NULL at the start
Result_Hyperframe <- NULL

# Adjusted add_to_hyperframe function to dynamically build the hyperframe
add_to_hyperframe <- function(...) {
  if (is.null(Result_Hyperframe)) {
    Result_Hyperframe <<- hyperframe(...)
  } else {
    Result_Hyperframe <<- tryCatch({
      rbind(Result_Hyperframe, hyperframe(...))
    }, error = function(e) {
      cat("Error in rbind: ", e$message, "\n")
    })
  }
}

# Adjusted function to create point patterns
create_point_pattern <- function(Data_Subset) {
  xlim <- range(Data_Subset$CenterX)
  ylim <- range(Data_Subset$CenterY)

  Cells_PPP <- spatstat.geom::ppp(x = Data_Subset$CenterX, y = Data_Subset$CenterY, xrange = xlim, yrange = ylim)
  unitname(Cells_PPP) <- list("mm", "mm", 2.34264/5160)
  Cells_PPP <- spatstat.geom::rescale(Cells_PPP)
  
  return(Cells_PPP)
}

# Iterate over unique MouseIDs to process and create point patterns for both Klf4 and Dapi
mouse_ids <- unique(Klf4_Data$MouseID)

for (mouse_id in mouse_ids) {
  Subset_Klf4 <- Klf4_Data[Klf4_Data$MouseID == mouse_id, ]
  Subset_Dapi <- Dapi_Data[Dapi_Data$MouseID == mouse_id, ]
  
  if(nrow(Subset_Klf4) > 0 && nrow(Subset_Dapi) > 0) {
    Klf4_PPP <- create_point_pattern(Subset_Klf4)
    Dapi_PPP <- create_point_pattern(Subset_Dapi)
    
    # Set the observation window for Klf4 based on Dapi's convex hull
    Window(Klf4_PPP) <- convexhull(Dapi_PPP)
    
    dpi2_value <- unique(Subset_Klf4$DPI)[1]
    
    add_to_hyperframe(Klf4 = Klf4_PPP, Dapi = Dapi_PPP, ID = as.character(mouse_id), DPI = as.factor(dpi2_value), stringsAsFactors = TRUE)
  } else {
    message(sprintf("Skipping MouseID %s due to insufficient data.\n", mouse_id))
  }
}

# Save the Result_Hyperframe
Result_Hyperframe$DPI <- factor(Result_Hyperframe$DPI, levels = c("0D", "3D", "7D", "14D", "30D"))

saveRDS(Result_Hyperframe, "PointPatterns/Widefield_10x_Ipsilateral_Klf4_PPP.rds")
```

The point patterns are created and stored. In the next, chunk, we load the point patterns and add density kernels. Please check the `Widefield_10x_Pdgfrb-Gfap_Covariance`notebook for more information in this regard.

## Calculate density kernels

We use the `density` function to calculate density kernels with a sigma of 0.02.

```{r}
#| label: tbl-Klf4_Densitykernels
#| include: true
#| warning: false
#| message: false

# Load the point patterns
PointPatterns <- readRDS("PointPatterns/Widefield_10x_Ipsilateral_Klf4_PPP.rds")

# We add animal's ID as raw names
row.names(PointPatterns) <- PointPatterns$ID

# We rotate the point patterns
PointPatterns$Klf4 <- with(PointPatterns, rotate.ppp(Klf4, pi/2))
PointPatterns$Klf4 <- with(PointPatterns, flipxy(Klf4))

# Add density kernels to the hyperframe
PointPatterns$Klf4_Density <- with (PointPatterns, density(Klf4, sigma = 0.02))
```

### Plot density kernels

For visualization purposes, we plot some examples of the density kernels. We observe that KLF4+ cells tend to aggregate in the ischemic cortex (to the left) as the injury progresses.

```{r}
#| label: tbl-Klf4_Plotkernels
#| include: true
#| warning: false
#| message: false
#| fig-cap: Example density kernels for KLF4
#| fig-height: 5
#| fig-width: 9

Klf4_Colmap <- colourmap(topo.colors(256), range = c(0, 20000))

par(mfrow = c(2,5), mar=c(1,1,1,1), oma=c(1,1,1,1))

plot(PointPatterns$Klf4_Density$Td069, col = Klf4_Colmap, main = "0 DPI")  
plot(PointPatterns$Klf4_Density$Td072, col = Klf4_Colmap, main = "3 DPI")
plot(PointPatterns$Klf4_Density$Td018, col = Klf4_Colmap, main = "7 DPI")
plot(PointPatterns$Klf4_Density$Td055, col = Klf4_Colmap, main = "14 DPI")
plot(PointPatterns$Klf4_Density$Td048, col = Klf4_Colmap, main = "30 DPI")
```
## Modeling point pattern process

In this section we use the `mppm` function from `spatstat` to fit a **log-linear model** for replicated point patterns. This model allow us to quantify KLF4 allocation changes conditional on the x coordinate of the ischemic hemisphere. This is relevant for us given the specific injury site. In this case, we use a multilevel model with random intercepts and slopes for the x coordinate. The model specification is as follows: 

## Statistical Model Specification

The spatial intensity of KLF4 expression was modeled using a multiplicative Poisson point process model (mppm), applied to a dataset comprising 52 point patterns. The model aimed to assess how the spatial distribution of KLF4 expression varies with the x-coordinate, conditional on the developmental period (DPI). The model can be specified in statistical notation as follows:

$$
KLF4_i(x) \sim \text{Poisson}(\lambda(x, \text{DPI}_i)) 
$$

where $i$ indexes the point pattern (corresponding to a unique DPI), and $x$ represents the spatial coordinate. The intensity function $\lambda(x, \text{DPI}_i)$ is modeled as:

$$
\log(\lambda(x, \text{DPI}_i)) = \beta_0 + \beta_1 x + u_{0i} + u_{1i}x
$$
Where $\beta_0$ and $\beta_1$ are fixed effects, representing the baseline log intensity of KLF4 expression and the effect of the x-coordinate on this intensity, respectively.$u_{0i}$ and $u_{1i}$ are random effects for the intercept and slope, varying by DPI, to capture the variability in KLF4 expression intensity and its spatial variation across different injury stages.

### Fit the mppm model

We fit the model using the `mppm` function for treating replicated point patterns as those in out hyperframe. 

```{r}
#| label: Klf4_mppm
#| include: true
#| warning: false
#| message: false


Klf4_Int_mppm <- mppm(Klf4 ~ x, random = ~ x | DPI, data = PointPatterns)

summary(Klf4_Int_mppm)
```
The results of this Poisson regression are present in the log scale. Here, we see the Intercept (8.7), the baseline of KLF4 log-intensity at 0 DPI.The slope (-0.62) indicates that the spatial intensity of KLF4 changes as we move along the x-axis. The negative sign denotes that as x increases, the spatial intensity of KLF4 decreases. Now, the random effects coefficients account for variations that occur at different injury stages. We see that 3D is -0.58, indicating a lower baseline intensity for KLF4 at this stage, while at 14D we see a higher baseline intensity (0.57). The slopes in the random intercepts indicate the rate change as we move across the x-axis. At 0D,a positive adjustment (e.g., 0.30) denotes that the decrease in KLF4 intensity is less pronounced or even reversed at this stage. On the other hand, the negative adjustment at 14D (-0.89) means the decrease is more pronounced.

Overall, these results show a more pronounced increase of KLF4 at 14D and 7D as we move away from the infarct zone, indicating an aggregation of KLF4 in the ischemic zones.


## Generate table for mean intensity

Here, we extract the mean spatial intensity of each point pattern to perform a regression.

```{r}
#| label: tbl-Klf4_ExtractIntensity
#| include: true
#| warning: false
#| message: false

# Initialize an empty data frame to store the results
Klf4_Intensity <- data.frame(MouseID=character(), DPI=factor(), Intensity=integer(), stringsAsFactors = FALSE)

# Iterate over the rows of the hyperframe to calculate intensity for each Klf4 pattern
for (i in 1:nrow(PointPatterns)) {
  # Calculate the intensity of the Klf4 point pattern for the current row
  current_intensity <- summary(PointPatterns$Klf4[[i]])$intensity
  
  # Round the intensity value to have no decimals
  rounded_intensity <- round(current_intensity)
  
  # Extract MouseID and DPI2 for the current row
  current_mouse_id <- PointPatterns$ID[i]
  current_dpi2 <- PointPatterns$DPI[i]
  
  # Add the results to the data frame
  Klf4_Intensity  <- rbind(Klf4_Intensity, data.frame(MouseID=current_mouse_id, DPI2=current_dpi2, Intensity=rounded_intensity))
}

# View the final data frame
print(Klf4_Intensity )

write.csv(Klf4_Intensity , "Data_Processed/Widefield_10x_Ipsilateral_Klf4/Widefield_10x_Ipsilateral_Klf4_Intensity.csv", row.names = FALSE)
```




# Analysis of KLF4 staining (labeling) intensity

## Dataset handling

We handle the `Klf4_Data` to add scaled coordinates

```{r}
#| label: Klf4_Int_Scale
#| include: true
#| warning: false
#| message: false
#| results: false
#| cache: true

Klf4_Data <- read.csv("Data_Processed/Widefield_10x_Ipsilateral_Klf4/Widefield_10x_Ipsilateral_Klf4_Klf4Inten.csv", header = TRUE)

## We set the factors
Klf4_Data$DPI <- factor(Klf4_Data$DPI, levels = c("0D", "3D", "7D", "14D", "30D"))

Klf4_Data <- Klf4_Data %>%
  group_by(MouseID) %>%
  mutate(Scaled_CenterX = (CenterX - min(CenterX)) / (max(CenterX) - min(CenterX)),
         Scaled_CenterY = (CenterY - min(CenterY)) / (max(CenterY) - min(CenterY))) %>%
  ungroup()

Klf4_Data$MouseID <- factor(Klf4_Data$MouseID)
```

## Exploratory data visualization

Next, we visualize the raw data to guide the statistical modeling. We plot the response variable as a density and a scatter plot (per DPI). In the scatter plot, we fit lines for a lineal (black), 2-degree (red), and 3-degree (green) polynomial models.

```{r}
#| label: fig-Klf4_CellInt_Expl
#| include: true
#| warning: false
#| message: false
#| results: false
#| fig-cap: Exploratory data visualization for Klf4 intensity
#| fig-width: 9
#| fig-height: 4

set.seed(8807)

# Density plot
################

Klf4_Int_Dens <- 
  ggplot(
    data  = Klf4_Data, 
    aes(x = Intensity)
    ) +
  geom_density(size = 1.5) +
  geom_rug(size = 1) +
  scale_x_continuous(name ="KLF4 (Intensity)") +
  scale_y_continuous(name = "Density") +
  Plot_theme


# Box plot
##################

Klf4_Int_Box <- 
  ggplot(
    data  = Klf4_Data, 
    aes(x = DPI, 
        y = Intensity)
    ) +
  geom_boxplot()+

Plot_theme

#Plot the result
Klf4_Int_Dens |  Klf4_Int_Box 
```

@fig-Klf4_CellInt_Expl shows a range of \~ 0 - 10 in the KFL4 intensity. Without accounting for days-post ischemia (DPI), the response variable exhibits a single concentrated peak. On the other hand, the scatter shows that there are no substantial differences between the fitted lines. We speculate that the median (per object) intensity of KLF4 does not vary meaningfully by DPI.

## Statistical modeling for Klf4 expression

We use the `brms` package [@brms; @burkner2018] to run Bayesian modeling. We employ weakly informative priors in all the cases to optimize the Markov chain Monte Carlo (MCMC) and the exploration of the parameter space. Given the exploratory data visualization, we fit a linear model to explore the variability of KLF4 by DPI. We build a multilevel model to take into consideration the clustering of cells per animal:

-   **Klf4_Int_Mdl1:** This model employs a `hurdle_lognormal()` distribution to handle data with zeros while also capturing the continuous nature of the observations. This distribution is a two-part model having a binary Component predicting the probability of observing a zero versus a positive outcome; and a continuous Component for observations predicted to be positive:

$$
\begin{aligned}
\text{logit}(p_i) &= \beta_{\text{DPI}} \times \text{DPI}_i \\
\log(Y_i) &\sim N(\mu_i, \sigma^2), \quad Y_i > 0 \\
\mu_i &= \gamma_{\text{DPI}} \times \text{DPI}_i + b_{\text{MouseID}[i]} \\
b_{\text{MouseID}[i]} &\sim N(0, \tau^2)
\end{aligned}
$$
Where, $p_i$ is the probability of observing zero intensity for mouse $i$. $\beta_{\text{DPI}}$ is the coefficient for DPI affecting the log-odds of observing a zero outcome. $Y_i$ is the intensity for mouse
$i$ when it is positive.$\mu_i$ is the expected log-intensity for a positive outcome, influenced by DPI and the random effect of the mouse.$b_{\text{MouseID}[i]}$ is the random intercept for each mouse, modeled as a normal distribution with mean zero and variance $\tau^2$.

This model uses the default flat prior from `brms`:

$$
\begin{align}
\beta_{1} \sim Normal(0, 1), \sigma > 0\\
sd \sim Student-t(3, 0, 1) \\
\sigma \sim Student-t(3, 0, 1), \sigma > 0 \\
\end{align}
$$


-   **Klf4_Int_Mdl2:** This model uses a `hurdle_lognormal()` distribution implicating that the effect of DPI may vary depending the X location. The model takes the following formulation: 

$$
\text{For Zero vs. Positive Outcomes:} \\
\text{logit}(p_i) = \alpha_{\text{DPI}} \times \text{DPI}_i + \alpha_{\text{Location}} \times \text{Location}_i + \alpha_{\text{Interaction}} \times \text{DPI}_i \times \text{Location}_i \\
\text{For Positive Outcomes:} \\
\log(Y_i) \sim N(\mu_i, \sigma^2), \quad Y_i > 0 \\
\mu_i = \beta_{\text{DPI}} \times \text{DPI}_i + \beta_{\text{Location}} \times \text{Location}_i + \beta_{\text{Interaction}} \times \text{DPI}_i \times \text{Location}_i + b_{\text{MouseID}[i]} \\
b_{\text{MouseID}[i]} \sim N(0, \tau^2)
$$
This model use the same priors as model 1.

### Fit the models for Klf4 intensity

First, we subsample the data to make model feasible.

```{r}
#| label: Klf4_CellInt_Subsample
#| include: true
#| warning: false
#| message: false
#| results: false
#| cache: true

Klf4_Data <- Klf4_Data %>%
  mutate(MouseID = as.character(MouseID))

# Subsampling 10% of the cases for each MouseID
Klf4_Subsample <- Klf4_Data %>%
  group_by(MouseID) %>%
  sample_frac(0.1) %>%
  ungroup()  # Ungrouping to remove the grouping structure
```

Next, we fit the models using `brms`:

```{r}
#| label: Klf4_CellInt_Model
#| include: true
#| warning: false
#| message: false
#| results: false
#| cache: true

# Model 1

Klf4_CellInt_Mdl1 <- bf(Intensity ~ 0 + DPI + (1 | MouseID))

get_prior(Klf4_CellInt_Mdl1, Klf4_Subsample, family = hurdle_lognormal())

Klf4_CellInt_Prior1 <- 
  c(prior(normal(0,1), class = b, lb = 0),
    prior(student_t(3, 0, 1), class = sd, lb= 0),
    prior(student_t(3, 0, 1), class = sigma, lb=0))

# Fit model 1
Klf4_CellInt_Fit1 <- 
  brm(
    family  = hurdle_lognormal(),
    data    = Klf4_Subsample,
    formula = Klf4_CellInt_Mdl1,
    prior   = Klf4_CellInt_Prior1,
    chains  = 4,
    cores   = 4,
    warmup  = 2500, 
    iter    = 5000, 
    seed    = 8807,
    control = list(adapt_delta = 0.99, max_treedepth = 15),
    file    = "Models/Widefield_10x_Ipsilateral_Klf4_Exp/Widefield_10x_Ipsilateral_Klf4_CellInt_Fit1.rds",
    file_refit = "never")

                     
#Klf4_CellInt_Fit1 <- 
#  add_criterion(Klf4_CellInt_Fit1, c("loo", "waic", "bayes_R2"))


# Model 2

Klf4_CellInt_Mdl2 <- bf(Intensity ~ 0 + DPI * Scaled_CenterX + (1 | MouseID))

get_prior(Klf4_CellInt_Mdl2, Klf4_Subsample, family = lognormal())

# Fit model 1
Klf4_CellInt_Fit2 <- 
  brm(
    family = hurdle_lognormal(),
    data    = Klf4_Subsample,
    formula = Klf4_CellInt_Mdl2,
    prior   = Klf4_CellInt_Prior1,
    chains  = 4,
    cores   = 4,
    warmup  = 2500, 
    iter    = 5000, 
    seed    = 8807,
    control = list(adapt_delta = 0.99, max_treedepth = 15),
    file    = "Models/Widefield_10x_Ipsilateral_Klf4_Exp/Widefield_10x_Ipsilateral_Klf4_CellInt_Fit2.rds",
    file_refit = "never")

#Klf4_CellInt_Fit2 <- 
#  add_criterion(Klf4_CellInt_Fit2, c("loo", "waic", "bayes_R2"))
```
## Model diagnostics

We perform model diagnostics:

```{r}
#| label: fig-Klf4_CellInt_Diagnostics
#| include: true
#| warning: false
#| message: false
#| results: false
#| fig-cap: Model diagnostics for KLF4 expression in individual cells
#| fig-height: 5
#| fig-width: 10

set.seed(8807)

Klf4_CellInt_Fit1_pp <- 
  brms::pp_check(Klf4_CellInt_Fit1, 
                 ndraws = 100) +
  labs(title = "Posterior predictive checks",
  subtitle = "Formula: Intensity ~ 0 + DPI + (1 | MouseID)") +
  scale_x_continuous(limits=c(0, 0.05)) +
  Plot_theme  

Klf4_CellInt_Fit2_pp <- 
  brms::pp_check(Klf4_CellInt_Fit2, 
                 ndraws = 100) +
  labs(title = "Posterior predictive checks",
  subtitle = "Intensity ~ 0 + DPI * Scaled_CenterX + (1 | MouseID)") +
  scale_x_continuous(limits=c(0, 0.05)) +
  Plot_theme  
  
Klf4_CellInt_Fit1_pp | Klf4_CellInt_Fit2_pp
```

We see that the model predictions fit well with the observations in both cases.

## Model results

After validating the model, we plot the full posterior distributions:

### Visualizing the results

```{r}
#| label: fig-Klf4_CellInt_Posterior
#| include: true
#| warning: false
#| message: false
#| results: false
#| fig-cap: Posterior distribution for Klf4 expression
#| fig-width: 5
#| fig-height: 4

set.seed(8807)

Klf4_CellInt_DPI <- 
  conditional_effects(Klf4_CellInt_Fit1)

Klf4_CellInt_DPI <- plot(Klf4_CellInt_DPI, 
       plot = FALSE)[[1]]

Klf4_CellInt_fig <- Klf4_CellInt_DPI + 
  scale_y_continuous(name = expression ("KLF4 intensity (cells)"),
                     limits = c(0.005, 0.015)) +
  scale_x_discrete(name="DPI") +
  
  Plot_theme 

  ggsave(
  plot     = Klf4_CellInt_fig, 
  filename = "Plots/Widefield_10x_Ipsilateral_Klf4_Exp/Widefield_10x_Ipsilateral_Klf4_CellIntensity.png",   width    = 12, 
  height   = 9, 
  units    = "cm")

Klf4_CellInt_fig 
```

@fig-Klf4_CellInt_Posterior shows 95% intervals for the posterior distribution of KLF4 expression by cell. We can observe an increase from the second week post ischemia.

Now, we calculate the relevant contrast using the `emmeans` package [@emmeans].

```{r}
#| label: Klf4_CellInt_Contrast
#| include: true
#| warning: false
#| message: false
#| results: false

# We generate a data frame with the contrast
Klf4_CellInt_Contrast <- Klf4_CellInt_Fit1%>%
emmeans(~ DPI, var = "Intensity", epred = TRUE) %>%
contrast(method = "revpairwise") %>%
gather_emmeans_draws() %>% sample_n(100)

# Subset relevant data fo the contrast graph
Klf4_CellInt_Contrast_Sub <- Klf4_CellInt_Contrast[
  (Klf4_CellInt_Contrast$contrast=="3D - 0D"|
   Klf4_CellInt_Contrast$contrast=="7D - 3D"|
   Klf4_CellInt_Contrast$contrast=="14D - 7D"|
   Klf4_CellInt_Contrast$contrast=="30D - 14D"|
  Klf4_CellInt_Contrast$contrast=="30D - 0D"),]

Klf4_CellInt_Contrast_Sub$contrast <- 
  factor(Klf4_CellInt_Contrast_Sub$contrast, 
         levels = c("3D - 0D", "7D - 3D", "14D - 7D", "30D - 14D", "30D - 0D")) 
```

Next, we generate the graph:

```{r}
#| label: Klf4_CellInt_ContrastGraph
#| include: true
#| warning: false
#| message: false
#| results: false
#| fig-cap: Contrast by DPI for KLF4 spatial intensity
#| fig-width: 5
#| fig-height: 4

Klf4_CellInt_Contrast_Fig <- 
  Klf4_CellInt_Contrast_Sub %>%
  ggplot(
    aes(x    = .value, 
        y    = contrast
        #fill = after_stat(abs(x) < 800)
        )) +
  
  stat_slab() +
  
  #geom_vline(xintercept = c(-0.54, 0.54), linetype = "dashed") +
  
  stat_pointinterval(
    point_interval = mode_hdi, 
    position = position_dodge(width = .95, preserve = "single")) +
  
    #scale_fill_manual(
    #name="ROPE", 
    #values = c("gray80", "skyblue"),
    #labels = c("False", "True")) +
  
  scale_y_discrete(
    name= "",
    labels = c("3D - 0D", "7D - 3D", "14D - 7D", "30D - 14D", "30D - 0D")) +
  
  scale_x_continuous(
   name = "KLF4 cell intensity (contrast)",
   limits=c(-0.005, 0.006), 
   breaks=seq(-0.005, 0.005, 0.003)) +
  Plot_theme +
  
  theme (legend.position = c(0.8, 0.8))

ggsave(
  plot     = Klf4_CellInt_Contrast_Fig , 
  filename = "Plots/Widefield_10x_Ipsilateral_Klf4_Exp/Widefield_10x_Ipsi_Klf4_CellInt_Contrast_Fig.png", 
  width    = 12, 
  height   = 9, 
  units    = "cm")

Klf4_CellInt_Contrast_Fig

```

### Posterior summary

Next, we plot the posterior summary using the `describe_posterior` function from `bayestestR` package [@bayestestR; @makowski2019].

```{r}
#| label: Klf4_CellInt_Fit1_DescribePosterior
#| include: true
#| warning: false
#| message: false
#| results: false
#| cache: true

describe_posterior(
  Klf4_CellInt_Fit1,
  effects = "all",
  test = c("p_direction", "rope"),
  component = "all",
  centrality = "median")
```
The table displays the regression coefficients without a baseline (intercept value).It also shows he coefficients for individual animals included as group-level effects.


### Visluazing the results for the second model

On the other hand, we can also plot the posterior distribution for the sigma parameter:

```{r}
#| label: fig-Klf4_CellInt_Fit2_Posterior
#| include: true
#| warning: false
#| message: false
#| results: false
#| fig-cap: Posterior distribution for Klf4 expression
#| fig-width: 5
#| fig-height: 4

set.seed(8807)

Klf4_CellInt2_DPI <- 
  conditional_effects(Klf4_CellInt_Fit2)

Klf4_CellInt2_DPI <- plot(Klf4_CellInt2_DPI, 
       plot = FALSE)[[3]]

Klf4_CellInt2_fig <- Klf4_CellInt2_DPI + 
  scale_y_continuous(name = expression ("KLF4 intensity (cells)")) +
  scale_x_continuous(name="X-coordinates (normalized)") +
  
  Plot_theme +
  theme(
  legend.position = "top", legend.direction = "horizontal"
  )

  ggsave(
  plot     = Klf4_CellInt2_fig, 
  filename = "Plots/Widefield_10x_Ipsilateral_Klf4_Exp/Widefield_10x_Ipsilateral_Klf4_CellIntensity_Fit2.png",   
  width    = 12, 
  height   = 10, 
  units    = "cm")

Klf4_CellInt2_fig
```

### Posterior summary for the second model

Next, we plot the posterior summary using the `describe_posterior` function from `bayestestR` package [@bayestestR; @makowski2019].

```{r}
#| label: Klf4_CellInt2_DescribePosterior
#| include: true
#| warning: false
#| message: false
#| results: false
#| cache: true

describe_posterior(
  Klf4_CellInt_Fit2,
  effects = "all",
  test = c("p_direction", "rope"),
  component = "all",
  centrality = "median")

```

The table displays the regression coefficients without a baseline (intercept value). 


## Generate visualizations for cell intensity

Now, We'll save plot for in a designated folder to represent the intensity per cell.

```{r}
#| label: Klf4_CellInt_Visualization
#| include: true
#| warning: false
#| message: false
#| results: false
#| cache: true

plot_directory <- "Plots/Widefield_10x_Ipsilateral_Klf4_Exp/ScatterPlots"
dir.create(plot_directory, recursive = TRUE, showWarnings = FALSE)

# Get unique MouseIDs
mouse_ids <- unique(Klf4_Subsample$MouseID)
DPI <- unique(Klf4_Subsample$DPI)

# Loop through each MouseID
for(mouse_id in mouse_ids) {
  # Filter data for the current MouseID
  filtered_data <- filter(Klf4_Subsample, MouseID == mouse_id)
  
  # Create the plot
  plot <- ggplot(filtered_data, aes(x = Scaled_CenterX, y = Scaled_CenterY, color = Intensity)) +
  geom_point(alpha = 0.7) + 
  scale_y_reverse() + 
  labs(title = "",
       x = "X",
       y = "Y") +
  theme_minimal() +
  scale_color_viridis_c(limits = c(0, 0.03)) +
  Plot_theme +
  theme(
  legend.position = "right", legend.direction = "vertical"
  )

  # Save the plot
  ggsave(filename = paste(plot_directory, "/", mouse_id, "_", DPI, "_ScatterPlot.png", sep = ""),
         plot = plot, 
         width = 10, 
         height = 10, 
         units = "cm")
}
```


# References

::: {#refs}
:::

```{r}
sessionInfo()
```

